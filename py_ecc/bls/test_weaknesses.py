from py_ecc.bls import G2ProofOfPossession as bls
from py_ecc.bls.g2_primitives import *
from py_ecc.optimized_bls12_381.optimized_curve import *
from .hash_to_curve import hash_to_G2
from hashlib import sha256

import structlog

log = structlog.get_logger()


def test_partition_of_unity():
    """This test shows a weakness in bls, when private keys are a partition to 1 (1 = sk_0 + .... + sk_n %
    curve_order, with the special case private_key = 1 mod curve_order). If priv_key = 1, anyone can make
    create messages (withdrawal, slashable casper proposals, etc...)
    For the general case, essentially, an attacker (for instance, a malicious aggregator) can create
    conflicting attestations for the set of validators in a committee, who's private_keys sum up to 1. If this is the
    case can be detected by an attacker without knowledge of any private keys, by analyzing p2p traffic for the property
    bls.Aggregate([sig0, ..., sign] == message_hash. The likelihood of such message depends on the size of the
    validator set and p(1), the number of possible partitions 1 mod curve_order """

    # boilerplate
    m = b"message"
    sk0 = 1
    sk1 = 1111
    sk2 = 666
    DST = b"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_"

    # generating the message hash
    hash = G2_to_signature(hash_to_G2(m, DST, hash_function=sha256))

    one_key = G1_to_pubkey(G1)
    one_public_key = bls.SkToPk(sk0)

    # The public Key here is just the curve's generator
    assert one_key == one_public_key
    log.msg(one_key.hex())
    pk1 = bls.SkToPk(sk1)
    pk2 = bls.SkToPk(sk2)

    one_sigm = bls.Sign(sk0, m)

    assert one_sigm == hash
    sigm1 = bls.Sign(sk1, m)
    sigm2 = bls.Sign(sk2, m)

    log.msg(
        "If private key == 1 % curve_order, the signature is just the message's hash and can be generated by anyone",
        verification_result=bls.FastAggregateVerify(
            [one_key, pk1, pk2], m, bls.Aggregate([hash, sigm1, sigm2])
        ),
    )

    def generate_partition_of_unity(sk: int, n: int) -> list[int]:
        """ generates n keys that sum up to one % curve_order """
        sum_one_keys = [sk]
        while len(sum_one_keys) <= n:
            reciprocal_private_key = curve_order - sum(sum_one_keys) + 1
            if reciprocal_private_key == 0:
                log.msg("generated partition_of_unity", length=len(sum_one_keys))
                break
            sum_one_keys.append(reciprocal_private_key)
        assert (sum(sum_one_keys) % curve_order) == 1
        return sum_one_keys

    private_keys = generate_partition_of_unity(sk2, 10)
    public_keys = [bls.SkToPk(privkey) for privkey in private_keys]
    signatures = [bls.Sign(privkey, m) for privkey in private_keys]

    # check everything follows protocol
    for private_key in private_keys:
        assert bls._is_valid_privkey(private_key)
    for public_key in public_keys:
        assert bls._is_valid_pubkey(public_key)
    for signature in signatures:
        assert bls._is_valid_signature(signature)

    # this is the bug
    assert bls.Aggregate(signatures) == hash
    assert bls.FastAggregateVerify(public_keys, m, hash)

    log.msg(
        "For the general case, if 1 = sk_0 + .... + sk_n, the aggregated signature is just the hash of the message "
        "and can be generated by anyone",
        verification_result=bls.FastAggregateVerify(public_keys, m, hash),
    )


def test_aggregated_pubkeys():
    sk0 = 1234
    sk1 = 1111
    # horcrux keys
    pk0 = bls.SkToPk(sk0)
    pk1 = bls.SkToPk(sk1)

    # aggregated_key
    pk01 = bls._AggregatePKs([pk0, pk1])
    sk01 = sk0 + sk1
    m = b"message"
    m0 = b"message0"
    m1 = b"message1"

    # one attestation/proposal for attestation/proposal data
    sig0 = bls.Sign(sk0, m)
    # another attestation for the same attestation/proposal data
    sig1 = bls.Sign(sk1, m)
    sigm0 = bls.Sign(sk0, m0)
    sigm1 = bls.Sign(sk1, m1)
    sig01 = bls.Sign(sk01, m)
    # Aggregator aggregates signatueres of pk0 and pk1
    aggregated_signature = bls.Aggregate([sig0, sig1])
    # happy case in a validator, get aggregated_signature from aggregator and verifies against
    # set of pkeys
    log.msg(
        "the happy case of an aggregated attestation, bls.FastAggregateVerify([pk0, pk1], m, aggregated_signature)=",
        verification_result=bls.FastAggregateVerify(
            [pk0, pk1], m, aggregated_signature
        ),
    )

    log.msg(
        "sk01 by pk34, bls.FastAggregateVerify([pk01], m, sig01)=",
        verification_result=bls.FastAggregateVerify([pk01], m, sig01),
    )
    log.msg(
        "sig01 == aggregated_signature ? Yes. So we can aggregate private keys and sign or "
        "aggregate the signatures will be the same. Yay, Pairing! "
        "sig01 == bls.Aggregate([sig0, sig1]=",
        verification_result=sig01 == bls.Aggregate([sig0, sig1]),
    )

    log.msg(
        "sk01 by pk0, pk1",
        verification_result=bls.FastAggregateVerify([pk0, pk1], m, sig01),
    )
    log.msg("sk01 by pk0", verification_result=bls.FastAggregateVerify([pk0], m, sig01))

    log.msg(
        "sig0, sig1 by pk01",
        verification_result=bls.FastAggregateVerify(
            [pk01], m, bls.Aggregate([sig0, sig1])
        ),
    )

    log.msg(
        "sig0, sig1 by pk0, pk1",
        verification_result=bls.FastAggregateVerify(
            [pk0, pk1], m, bls.Aggregate([sig0, sig1])
        ),
    )
    log.msg(
        "sig0, sig1 by pk0, pk1",
        verification_result=bls.FastAggregateVerify(
            [pk0, pk1], m, bls.Aggregate([sig0, sig1])
        ),
    )

    log.msg(
        "sig0, sig1, sig01 by pk0, pk1",
        verification_result=bls.FastAggregateVerify(
            [pk0, pk1], m, bls.Aggregate([sig0, sig1, sig01])
        ),
    )

    log.msg(
        "sig1 by pk01",
        verification_result=bls.FastAggregateVerify(
            [pk0, pk1], m, bls.Aggregate([sig01])
        ),
    )
    log.msg(
        "AggregateVerify sigm0, sigm1 by pk0, pk1",
        verification_result=bls.AggregateVerify(
            [pk0, pk1], [m0, m1], bls.Aggregate([sigm0, sigm1])
        ),
    )

    log.msg(
        "AggregateVerify sigm0, sigm1 by pk01",
        veriverification_result=bls.AggregateVerify(
            [pk01], [m0, m1], bls.Aggregate([sigm0, sigm1])
        ),
    )

    # Eth2 Proposal Threat model

    # *_someone* deposits 32ETH to the ETH1 deposit contract with a bls PK as it's validator key

    # need to wait a bit to become an _active_ validator

    # All validators update their list of active validator, including _someone to the list at
    # some point

    # *_someone* gets randomly selected as proposer and/or aggregator

    # Is it possible for *_someone* to generate conflicting block proposals with an aggregated
    # signature, that is accepted (=verified to true against some pubkey) but is *not*
    # traceable back to *_someone*

    # Is it possible for *_someone* pubkeys to generate valid proposals as well of *_someone*
    # from subkeys (e.g. aggregated summands)?
